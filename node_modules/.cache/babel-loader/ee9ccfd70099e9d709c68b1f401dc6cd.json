{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport ReactDOM from 'react-dom';\nimport { elementTypeAcceptingRef } from '@material-ui/utils';\nimport Drawer, { getAnchor, isHorizontal } from '../Drawer/Drawer';\nimport { duration } from '../styles/transitions';\nimport withTheme from '../styles/withTheme';\nimport { getTransitionProps } from '../transitions/utils';\nimport NoSsr from '../NoSsr';\nimport SwipeArea from './SwipeArea'; // This value is closed to what browsers are using internally to\n// trigger a native scroll.\n\nvar UNCERTAINTY_THRESHOLD = 3; // px\n// We can only have one node at the time claiming ownership for handling the swipe.\n// Otherwise, the UX would be confusing.\n// That's why we use a singleton here.\n\nvar nodeThatClaimedTheSwipe = null; // Exported for test purposes.\n\nexport function reset() {\n  nodeThatClaimedTheSwipe = null;\n}\n\nfunction calculateCurrentX(anchor, touches) {\n  return anchor === 'right' ? document.body.offsetWidth - touches[0].pageX : touches[0].pageX;\n}\n\nfunction calculateCurrentY(anchor, touches) {\n  return anchor === 'bottom' ? window.innerHeight - touches[0].clientY : touches[0].clientY;\n}\n\nfunction getMaxTranslate(horizontalSwipe, paperInstance) {\n  return horizontalSwipe ? paperInstance.clientWidth : paperInstance.clientHeight;\n}\n\nfunction getTranslate(currentTranslate, startLocation, open, maxTranslate) {\n  return Math.min(Math.max(open ? startLocation - currentTranslate : maxTranslate + startLocation - currentTranslate, 0), maxTranslate);\n}\n\nvar useEnhancedEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;\nvar SwipeableDrawer = React.forwardRef(function SwipeableDrawer(props, ref) {\n  var anchor = props.anchor,\n      disableBackdropTransition = props.disableBackdropTransition,\n      disableDiscovery = props.disableDiscovery,\n      disableSwipeToOpen = props.disableSwipeToOpen,\n      hideBackdrop = props.hideBackdrop,\n      hysteresis = props.hysteresis,\n      minFlingVelocity = props.minFlingVelocity,\n      _props$ModalProps = props.ModalProps;\n  _props$ModalProps = _props$ModalProps === void 0 ? {} : _props$ModalProps;\n\n  var BackdropProps = _props$ModalProps.BackdropProps,\n      ModalPropsProp = _objectWithoutProperties(_props$ModalProps, [\"BackdropProps\"]),\n      onClose = props.onClose,\n      onOpen = props.onOpen,\n      open = props.open,\n      _props$PaperProps = props.PaperProps,\n      PaperProps = _props$PaperProps === void 0 ? {} : _props$PaperProps,\n      SwipeAreaProps = props.SwipeAreaProps,\n      swipeAreaWidth = props.swipeAreaWidth,\n      theme = props.theme,\n      transitionDuration = props.transitionDuration,\n      variant = props.variant,\n      other = _objectWithoutProperties(props, [\"anchor\", \"disableBackdropTransition\", \"disableDiscovery\", \"disableSwipeToOpen\", \"hideBackdrop\", \"hysteresis\", \"minFlingVelocity\", \"ModalProps\", \"onClose\", \"onOpen\", \"open\", \"PaperProps\", \"SwipeAreaProps\", \"swipeAreaWidth\", \"theme\", \"transitionDuration\", \"variant\"]);\n\n  var _React$useState = React.useState(false),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      maybeSwiping = _React$useState2[0],\n      setMaybeSwiping = _React$useState2[1];\n\n  var swipeInstance = React.useRef({\n    isSwiping: null\n  });\n  var swipeAreaRef = React.useRef();\n  var backdropRef = React.useRef();\n  var paperRef = React.useRef();\n  var touchDetected = React.useRef(false);\n  var openRef = React.useRef(open); // Use a ref so the open value used is always up to date inside useCallback.\n\n  useEnhancedEffect(function () {\n    openRef.current = open;\n  }, [open]);\n  var setPosition = React.useCallback(function (translate) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$mode = options.mode,\n        mode = _options$mode === void 0 ? null : _options$mode,\n        _options$changeTransi = options.changeTransition,\n        changeTransition = _options$changeTransi === void 0 ? true : _options$changeTransi;\n    var anchorRtl = getAnchor(theme, anchor);\n    var rtlTranslateMultiplier = ['right', 'bottom'].indexOf(anchorRtl) !== -1 ? 1 : -1;\n    var horizontalSwipe = isHorizontal(anchor);\n    var transform = horizontalSwipe ? \"translate(\".concat(rtlTranslateMultiplier * translate, \"px, 0)\") : \"translate(0, \".concat(rtlTranslateMultiplier * translate, \"px)\");\n    var drawerStyle = paperRef.current.style;\n    drawerStyle.webkitTransform = transform;\n    drawerStyle.transform = transform;\n    var transition = '';\n\n    if (mode) {\n      transition = theme.transitions.create('all', getTransitionProps({\n        timeout: transitionDuration\n      }, {\n        mode: mode\n      }));\n    }\n\n    if (changeTransition) {\n      drawerStyle.webkitTransition = transition;\n      drawerStyle.transition = transition;\n    }\n\n    if (!disableBackdropTransition && !hideBackdrop) {\n      var backdropStyle = backdropRef.current.style;\n      backdropStyle.opacity = 1 - translate / getMaxTranslate(horizontalSwipe, paperRef.current);\n\n      if (changeTransition) {\n        backdropStyle.webkitTransition = transition;\n        backdropStyle.transition = transition;\n      }\n    }\n  }, [anchor, disableBackdropTransition, hideBackdrop, theme, transitionDuration]);\n  var handleBodyTouchEnd = React.useCallback(function (event) {\n    if (!touchDetected.current) {\n      return;\n    }\n\n    nodeThatClaimedTheSwipe = null;\n    touchDetected.current = false;\n    setMaybeSwiping(false); // The swipe wasn't started.\n\n    if (!swipeInstance.current.isSwiping) {\n      swipeInstance.current.isSwiping = null;\n      return;\n    }\n\n    swipeInstance.current.isSwiping = null;\n    var anchorRtl = getAnchor(theme, anchor);\n    var horizontal = isHorizontal(anchor);\n    var current;\n\n    if (horizontal) {\n      current = calculateCurrentX(anchorRtl, event.changedTouches);\n    } else {\n      current = calculateCurrentY(anchorRtl, event.changedTouches);\n    }\n\n    var startLocation = horizontal ? swipeInstance.current.startX : swipeInstance.current.startY;\n    var maxTranslate = getMaxTranslate(horizontal, paperRef.current);\n    var currentTranslate = getTranslate(current, startLocation, openRef.current, maxTranslate);\n    var translateRatio = currentTranslate / maxTranslate;\n\n    if (openRef.current) {\n      if (swipeInstance.current.velocity > minFlingVelocity || translateRatio > hysteresis) {\n        onClose();\n      } else {\n        // Reset the position, the swipe was aborted.\n        setPosition(0, {\n          mode: 'exit'\n        });\n      }\n\n      return;\n    }\n\n    if (swipeInstance.current.velocity < -minFlingVelocity || 1 - translateRatio > hysteresis) {\n      onOpen();\n    } else {\n      // Reset the position, the swipe was aborted.\n      setPosition(getMaxTranslate(horizontal, paperRef.current), {\n        mode: 'enter'\n      });\n    }\n  }, [anchor, hysteresis, minFlingVelocity, onClose, onOpen, setPosition, theme]);\n  var handleBodyTouchMove = React.useCallback(function (event) {\n    // the ref may be null when a parent component updates while swiping\n    if (!paperRef.current || !touchDetected.current) {\n      return;\n    }\n\n    var anchorRtl = getAnchor(theme, anchor);\n    var horizontalSwipe = isHorizontal(anchor);\n    var currentX = calculateCurrentX(anchorRtl, event.touches);\n    var currentY = calculateCurrentY(anchorRtl, event.touches); // We don't know yet.\n\n    if (swipeInstance.current.isSwiping == null) {\n      var dx = Math.abs(currentX - swipeInstance.current.startX);\n      var dy = Math.abs(currentY - swipeInstance.current.startY); // We are likely to be swiping, let's prevent the scroll event on iOS.\n\n      if (dx > dy) {\n        if (event.cancelable) {\n          event.preventDefault();\n        }\n      }\n\n      var definitelySwiping = horizontalSwipe ? dx > dy && dx > UNCERTAINTY_THRESHOLD : dy > dx && dy > UNCERTAINTY_THRESHOLD;\n\n      if (definitelySwiping === true || (horizontalSwipe ? dy > UNCERTAINTY_THRESHOLD : dx > UNCERTAINTY_THRESHOLD)) {\n        swipeInstance.current.isSwiping = definitelySwiping;\n\n        if (!definitelySwiping) {\n          handleBodyTouchEnd(event);\n          return;\n        } // Shift the starting point.\n\n\n        swipeInstance.current.startX = currentX;\n        swipeInstance.current.startY = currentY; // Compensate for the part of the drawer displayed on touch start.\n\n        if (!disableDiscovery && !openRef.current) {\n          if (horizontalSwipe) {\n            swipeInstance.current.startX -= swipeAreaWidth;\n          } else {\n            swipeInstance.current.startY -= swipeAreaWidth;\n          }\n        }\n      }\n    }\n\n    if (!swipeInstance.current.isSwiping) {\n      return;\n    }\n\n    var startLocation = horizontalSwipe ? swipeInstance.current.startX : swipeInstance.current.startY;\n    var maxTranslate = getMaxTranslate(horizontalSwipe, paperRef.current);\n    var translate = getTranslate(horizontalSwipe ? currentX : currentY, startLocation, openRef.current, maxTranslate);\n\n    if (swipeInstance.current.lastTranslate === null) {\n      swipeInstance.current.lastTranslate = translate;\n      swipeInstance.current.lastTime = performance.now() + 1;\n    }\n\n    var velocity = (translate - swipeInstance.current.lastTranslate) / (performance.now() - swipeInstance.current.lastTime) * 1e3; // Low Pass filter.\n\n    swipeInstance.current.velocity = swipeInstance.current.velocity * 0.4 + velocity * 0.6;\n    swipeInstance.current.lastTranslate = translate;\n    swipeInstance.current.lastTime = performance.now(); // We are swiping, let's prevent the scroll event on iOS.\n\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n\n    setPosition(translate);\n  }, [setPosition, handleBodyTouchEnd, anchor, disableDiscovery, swipeAreaWidth, theme]);\n  var handleBodyTouchStart = React.useCallback(function (event) {\n    // We are not supposed to handle this touch move.\n    if (nodeThatClaimedTheSwipe !== null && nodeThatClaimedTheSwipe !== swipeInstance.current) {\n      return;\n    }\n\n    var anchorRtl = getAnchor(theme, anchor);\n    var horizontalSwipe = isHorizontal(anchor);\n    var currentX = calculateCurrentX(anchorRtl, event.touches);\n    var currentY = calculateCurrentY(anchorRtl, event.touches);\n\n    if (!openRef.current) {\n      if (disableSwipeToOpen || event.target !== swipeAreaRef.current) {\n        return;\n      }\n\n      if (horizontalSwipe) {\n        if (currentX > swipeAreaWidth) {\n          return;\n        }\n      } else if (currentY > swipeAreaWidth) {\n        return;\n      }\n    }\n\n    nodeThatClaimedTheSwipe = swipeInstance.current;\n    swipeInstance.current.startX = currentX;\n    swipeInstance.current.startY = currentY;\n    setMaybeSwiping(true);\n\n    if (!openRef.current && paperRef.current) {\n      // The ref may be null when a parent component updates while swiping.\n      setPosition(getMaxTranslate(horizontalSwipe, paperRef.current) + (disableDiscovery ? 20 : -swipeAreaWidth), {\n        changeTransition: false\n      });\n    }\n\n    swipeInstance.current.velocity = 0;\n    swipeInstance.current.lastTime = null;\n    swipeInstance.current.lastTranslate = null;\n    touchDetected.current = true;\n  }, [setPosition, anchor, disableDiscovery, disableSwipeToOpen, swipeAreaWidth, theme]);\n  React.useEffect(function () {\n    if (variant === 'temporary') {\n      document.body.addEventListener('touchstart', handleBodyTouchStart);\n      document.body.addEventListener('touchmove', handleBodyTouchMove, {\n        passive: false\n      });\n      document.body.addEventListener('touchend', handleBodyTouchEnd);\n      return function () {\n        document.body.removeEventListener('touchstart', handleBodyTouchStart);\n        document.body.removeEventListener('touchmove', handleBodyTouchMove, {\n          passive: false\n        });\n        document.body.removeEventListener('touchend', handleBodyTouchEnd);\n      };\n    }\n\n    return undefined;\n  }, [variant, handleBodyTouchStart, handleBodyTouchMove, handleBodyTouchEnd]);\n  React.useEffect(function () {\n    return function () {\n      // We need to release the lock.\n      if (nodeThatClaimedTheSwipe === swipeInstance.current) {\n        nodeThatClaimedTheSwipe = null;\n      }\n    };\n  }, []);\n  React.useEffect(function () {\n    if (!open) {\n      setMaybeSwiping(false);\n    }\n  }, [open]);\n  var handleBackdropRef = React.useCallback(function (instance) {\n    // #StrictMode ready\n    backdropRef.current = ReactDOM.findDOMNode(instance);\n  }, []);\n  var handlePaperRef = React.useCallback(function (instance) {\n    // #StrictMode ready\n    paperRef.current = ReactDOM.findDOMNode(instance);\n  }, []);\n  return React.createElement(React.Fragment, null, React.createElement(Drawer, _extends({\n    open: variant === 'temporary' && maybeSwiping ? true : open,\n    variant: variant,\n    ModalProps: _extends({\n      BackdropProps: _extends({}, BackdropProps, {\n        ref: handleBackdropRef\n      })\n    }, ModalPropsProp),\n    PaperProps: _extends({}, PaperProps, {\n      style: _extends({\n        pointerEvents: variant === 'temporary' && !open ? 'none' : ''\n      }, PaperProps.style),\n      ref: handlePaperRef\n    }),\n    anchor: anchor,\n    transitionDuration: transitionDuration,\n    onClose: onClose,\n    ref: ref\n  }, other)), !disableSwipeToOpen && variant === 'temporary' && React.createElement(NoSsr, null, React.createElement(SwipeArea, _extends({\n    anchor: anchor,\n    ref: swipeAreaRef,\n    width: swipeAreaWidth\n  }, SwipeAreaProps))));\n});\nprocess.env.NODE_ENV !== \"production\" ? SwipeableDrawer.propTypes = {\n  /**\n   * @ignore\n   */\n  anchor: PropTypes.oneOf(['left', 'top', 'right', 'bottom']),\n\n  /**\n   * Disable the backdrop transition.\n   * This can improve the FPS on low-end devices.\n   */\n  disableBackdropTransition: PropTypes.bool,\n\n  /**\n   * If `true`, touching the screen near the edge of the drawer will not slide in the drawer a bit\n   * to promote accidental discovery of the swipe gesture.\n   */\n  disableDiscovery: PropTypes.bool,\n\n  /**\n   * If `true`, swipe to open is disabled. This is useful in browsers where swiping triggers\n   * navigation actions. Swipe to open is disabled on iOS browsers by default.\n   */\n  disableSwipeToOpen: PropTypes.bool,\n\n  /**\n   * @ignore\n   */\n  hideBackdrop: PropTypes.bool,\n\n  /**\n   * Affects how far the drawer must be opened/closed to change his state.\n   * Specified as percent (0-1) of the width of the drawer\n   */\n  hysteresis: PropTypes.number,\n\n  /**\n   * Defines, from which (average) velocity on, the swipe is\n   * defined as complete although hysteresis isn't reached.\n   * Good threshold is between 250 - 1000 px/s\n   */\n  minFlingVelocity: PropTypes.number,\n\n  /**\n   * @ignore\n   */\n  ModalProps: PropTypes.shape({\n    BackdropProps: PropTypes.shape({\n      component: elementTypeAcceptingRef\n    })\n  }),\n\n  /**\n   * Callback fired when the component requests to be closed.\n   *\n   * @param {object} event The event source of the callback\n   */\n  onClose: PropTypes.func.isRequired,\n\n  /**\n   * Callback fired when the component requests to be opened.\n   *\n   * @param {object} event The event source of the callback\n   */\n  onOpen: PropTypes.func.isRequired,\n\n  /**\n   * If `true`, the drawer is open.\n   */\n  open: PropTypes.bool.isRequired,\n\n  /**\n   * @ignore\n   */\n  PaperProps: PropTypes.shape({\n    component: elementTypeAcceptingRef\n  }),\n\n  /**\n   * Properties applied to the swipe area element.\n   */\n  SwipeAreaProps: PropTypes.object,\n\n  /**\n   * The width of the left most (or right most) area in pixels where the\n   * drawer can be swiped open from.\n   */\n  swipeAreaWidth: PropTypes.number,\n\n  /**\n   * @ignore\n   */\n  theme: PropTypes.object.isRequired,\n\n  /**\n   * The duration for the transition, in milliseconds.\n   * You may specify a single timeout for all transitions, or individually with an object.\n   */\n  transitionDuration: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({\n    enter: PropTypes.number,\n    exit: PropTypes.number\n  })]),\n\n  /**\n   * @ignore\n   */\n  variant: PropTypes.oneOf(['permanent', 'persistent', 'temporary'])\n} : void 0;\nSwipeableDrawer.defaultProps = {\n  anchor: 'left',\n  disableBackdropTransition: false,\n  disableDiscovery: false,\n  disableSwipeToOpen: typeof navigator !== 'undefined' && /iPad|iPhone|iPod/.test(navigator.userAgent),\n  hysteresis: 0.55,\n  minFlingVelocity: 400,\n  swipeAreaWidth: 20,\n  transitionDuration: {\n    enter: duration.enteringScreen,\n    exit: duration.leavingScreen\n  },\n  variant: 'temporary' // Mobile first.\n\n};\nexport default withTheme(SwipeableDrawer);","map":{"version":3,"sources":["/Users/tristan2020/Documents/test folder/newdata03/node_modules/@material-ui/core/esm/SwipeableDrawer/SwipeableDrawer.js"],"names":["_extends","_slicedToArray","_objectWithoutProperties","React","PropTypes","ReactDOM","elementTypeAcceptingRef","Drawer","getAnchor","isHorizontal","duration","withTheme","getTransitionProps","NoSsr","SwipeArea","UNCERTAINTY_THRESHOLD","nodeThatClaimedTheSwipe","reset","calculateCurrentX","anchor","touches","document","body","offsetWidth","pageX","calculateCurrentY","window","innerHeight","clientY","getMaxTranslate","horizontalSwipe","paperInstance","clientWidth","clientHeight","getTranslate","currentTranslate","startLocation","open","maxTranslate","Math","min","max","useEnhancedEffect","useLayoutEffect","useEffect","SwipeableDrawer","forwardRef","props","ref","disableBackdropTransition","disableDiscovery","disableSwipeToOpen","hideBackdrop","hysteresis","minFlingVelocity","_props$ModalProps","ModalProps","BackdropProps","ModalPropsProp","onClose","onOpen","_props$PaperProps","PaperProps","SwipeAreaProps","swipeAreaWidth","theme","transitionDuration","variant","other","_React$useState","useState","_React$useState2","maybeSwiping","setMaybeSwiping","swipeInstance","useRef","isSwiping","swipeAreaRef","backdropRef","paperRef","touchDetected","openRef","current","setPosition","useCallback","translate","options","arguments","length","undefined","_options$mode","mode","_options$changeTransi","changeTransition","anchorRtl","rtlTranslateMultiplier","indexOf","transform","concat","drawerStyle","style","webkitTransform","transition","transitions","create","timeout","webkitTransition","backdropStyle","opacity","handleBodyTouchEnd","event","horizontal","changedTouches","startX","startY","translateRatio","velocity","handleBodyTouchMove","currentX","currentY","dx","abs","dy","cancelable","preventDefault","definitelySwiping","lastTranslate","lastTime","performance","now","handleBodyTouchStart","target","addEventListener","passive","removeEventListener","handleBackdropRef","instance","findDOMNode","handlePaperRef","createElement","Fragment","pointerEvents","width","process","env","NODE_ENV","propTypes","oneOf","bool","number","shape","component","func","isRequired","object","oneOfType","enter","exit","defaultProps","navigator","test","userAgent","enteringScreen","leavingScreen"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/extends\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport ReactDOM from 'react-dom';\nimport { elementTypeAcceptingRef } from '@material-ui/utils';\nimport Drawer, { getAnchor, isHorizontal } from '../Drawer/Drawer';\nimport { duration } from '../styles/transitions';\nimport withTheme from '../styles/withTheme';\nimport { getTransitionProps } from '../transitions/utils';\nimport NoSsr from '../NoSsr';\nimport SwipeArea from './SwipeArea'; // This value is closed to what browsers are using internally to\n// trigger a native scroll.\n\nvar UNCERTAINTY_THRESHOLD = 3; // px\n// We can only have one node at the time claiming ownership for handling the swipe.\n// Otherwise, the UX would be confusing.\n// That's why we use a singleton here.\n\nvar nodeThatClaimedTheSwipe = null; // Exported for test purposes.\n\nexport function reset() {\n  nodeThatClaimedTheSwipe = null;\n}\n\nfunction calculateCurrentX(anchor, touches) {\n  return anchor === 'right' ? document.body.offsetWidth - touches[0].pageX : touches[0].pageX;\n}\n\nfunction calculateCurrentY(anchor, touches) {\n  return anchor === 'bottom' ? window.innerHeight - touches[0].clientY : touches[0].clientY;\n}\n\nfunction getMaxTranslate(horizontalSwipe, paperInstance) {\n  return horizontalSwipe ? paperInstance.clientWidth : paperInstance.clientHeight;\n}\n\nfunction getTranslate(currentTranslate, startLocation, open, maxTranslate) {\n  return Math.min(Math.max(open ? startLocation - currentTranslate : maxTranslate + startLocation - currentTranslate, 0), maxTranslate);\n}\n\nvar useEnhancedEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;\nvar SwipeableDrawer = React.forwardRef(function SwipeableDrawer(props, ref) {\n  var anchor = props.anchor,\n      disableBackdropTransition = props.disableBackdropTransition,\n      disableDiscovery = props.disableDiscovery,\n      disableSwipeToOpen = props.disableSwipeToOpen,\n      hideBackdrop = props.hideBackdrop,\n      hysteresis = props.hysteresis,\n      minFlingVelocity = props.minFlingVelocity,\n      _props$ModalProps = props.ModalProps;\n  _props$ModalProps = _props$ModalProps === void 0 ? {} : _props$ModalProps;\n\n  var BackdropProps = _props$ModalProps.BackdropProps,\n      ModalPropsProp = _objectWithoutProperties(_props$ModalProps, [\"BackdropProps\"]),\n      onClose = props.onClose,\n      onOpen = props.onOpen,\n      open = props.open,\n      _props$PaperProps = props.PaperProps,\n      PaperProps = _props$PaperProps === void 0 ? {} : _props$PaperProps,\n      SwipeAreaProps = props.SwipeAreaProps,\n      swipeAreaWidth = props.swipeAreaWidth,\n      theme = props.theme,\n      transitionDuration = props.transitionDuration,\n      variant = props.variant,\n      other = _objectWithoutProperties(props, [\"anchor\", \"disableBackdropTransition\", \"disableDiscovery\", \"disableSwipeToOpen\", \"hideBackdrop\", \"hysteresis\", \"minFlingVelocity\", \"ModalProps\", \"onClose\", \"onOpen\", \"open\", \"PaperProps\", \"SwipeAreaProps\", \"swipeAreaWidth\", \"theme\", \"transitionDuration\", \"variant\"]);\n\n  var _React$useState = React.useState(false),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      maybeSwiping = _React$useState2[0],\n      setMaybeSwiping = _React$useState2[1];\n\n  var swipeInstance = React.useRef({\n    isSwiping: null\n  });\n  var swipeAreaRef = React.useRef();\n  var backdropRef = React.useRef();\n  var paperRef = React.useRef();\n  var touchDetected = React.useRef(false);\n  var openRef = React.useRef(open); // Use a ref so the open value used is always up to date inside useCallback.\n\n  useEnhancedEffect(function () {\n    openRef.current = open;\n  }, [open]);\n  var setPosition = React.useCallback(function (translate) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$mode = options.mode,\n        mode = _options$mode === void 0 ? null : _options$mode,\n        _options$changeTransi = options.changeTransition,\n        changeTransition = _options$changeTransi === void 0 ? true : _options$changeTransi;\n    var anchorRtl = getAnchor(theme, anchor);\n    var rtlTranslateMultiplier = ['right', 'bottom'].indexOf(anchorRtl) !== -1 ? 1 : -1;\n    var horizontalSwipe = isHorizontal(anchor);\n    var transform = horizontalSwipe ? \"translate(\".concat(rtlTranslateMultiplier * translate, \"px, 0)\") : \"translate(0, \".concat(rtlTranslateMultiplier * translate, \"px)\");\n    var drawerStyle = paperRef.current.style;\n    drawerStyle.webkitTransform = transform;\n    drawerStyle.transform = transform;\n    var transition = '';\n\n    if (mode) {\n      transition = theme.transitions.create('all', getTransitionProps({\n        timeout: transitionDuration\n      }, {\n        mode: mode\n      }));\n    }\n\n    if (changeTransition) {\n      drawerStyle.webkitTransition = transition;\n      drawerStyle.transition = transition;\n    }\n\n    if (!disableBackdropTransition && !hideBackdrop) {\n      var backdropStyle = backdropRef.current.style;\n      backdropStyle.opacity = 1 - translate / getMaxTranslate(horizontalSwipe, paperRef.current);\n\n      if (changeTransition) {\n        backdropStyle.webkitTransition = transition;\n        backdropStyle.transition = transition;\n      }\n    }\n  }, [anchor, disableBackdropTransition, hideBackdrop, theme, transitionDuration]);\n  var handleBodyTouchEnd = React.useCallback(function (event) {\n    if (!touchDetected.current) {\n      return;\n    }\n\n    nodeThatClaimedTheSwipe = null;\n    touchDetected.current = false;\n    setMaybeSwiping(false); // The swipe wasn't started.\n\n    if (!swipeInstance.current.isSwiping) {\n      swipeInstance.current.isSwiping = null;\n      return;\n    }\n\n    swipeInstance.current.isSwiping = null;\n    var anchorRtl = getAnchor(theme, anchor);\n    var horizontal = isHorizontal(anchor);\n    var current;\n\n    if (horizontal) {\n      current = calculateCurrentX(anchorRtl, event.changedTouches);\n    } else {\n      current = calculateCurrentY(anchorRtl, event.changedTouches);\n    }\n\n    var startLocation = horizontal ? swipeInstance.current.startX : swipeInstance.current.startY;\n    var maxTranslate = getMaxTranslate(horizontal, paperRef.current);\n    var currentTranslate = getTranslate(current, startLocation, openRef.current, maxTranslate);\n    var translateRatio = currentTranslate / maxTranslate;\n\n    if (openRef.current) {\n      if (swipeInstance.current.velocity > minFlingVelocity || translateRatio > hysteresis) {\n        onClose();\n      } else {\n        // Reset the position, the swipe was aborted.\n        setPosition(0, {\n          mode: 'exit'\n        });\n      }\n\n      return;\n    }\n\n    if (swipeInstance.current.velocity < -minFlingVelocity || 1 - translateRatio > hysteresis) {\n      onOpen();\n    } else {\n      // Reset the position, the swipe was aborted.\n      setPosition(getMaxTranslate(horizontal, paperRef.current), {\n        mode: 'enter'\n      });\n    }\n  }, [anchor, hysteresis, minFlingVelocity, onClose, onOpen, setPosition, theme]);\n  var handleBodyTouchMove = React.useCallback(function (event) {\n    // the ref may be null when a parent component updates while swiping\n    if (!paperRef.current || !touchDetected.current) {\n      return;\n    }\n\n    var anchorRtl = getAnchor(theme, anchor);\n    var horizontalSwipe = isHorizontal(anchor);\n    var currentX = calculateCurrentX(anchorRtl, event.touches);\n    var currentY = calculateCurrentY(anchorRtl, event.touches); // We don't know yet.\n\n    if (swipeInstance.current.isSwiping == null) {\n      var dx = Math.abs(currentX - swipeInstance.current.startX);\n      var dy = Math.abs(currentY - swipeInstance.current.startY); // We are likely to be swiping, let's prevent the scroll event on iOS.\n\n      if (dx > dy) {\n        if (event.cancelable) {\n          event.preventDefault();\n        }\n      }\n\n      var definitelySwiping = horizontalSwipe ? dx > dy && dx > UNCERTAINTY_THRESHOLD : dy > dx && dy > UNCERTAINTY_THRESHOLD;\n\n      if (definitelySwiping === true || (horizontalSwipe ? dy > UNCERTAINTY_THRESHOLD : dx > UNCERTAINTY_THRESHOLD)) {\n        swipeInstance.current.isSwiping = definitelySwiping;\n\n        if (!definitelySwiping) {\n          handleBodyTouchEnd(event);\n          return;\n        } // Shift the starting point.\n\n\n        swipeInstance.current.startX = currentX;\n        swipeInstance.current.startY = currentY; // Compensate for the part of the drawer displayed on touch start.\n\n        if (!disableDiscovery && !openRef.current) {\n          if (horizontalSwipe) {\n            swipeInstance.current.startX -= swipeAreaWidth;\n          } else {\n            swipeInstance.current.startY -= swipeAreaWidth;\n          }\n        }\n      }\n    }\n\n    if (!swipeInstance.current.isSwiping) {\n      return;\n    }\n\n    var startLocation = horizontalSwipe ? swipeInstance.current.startX : swipeInstance.current.startY;\n    var maxTranslate = getMaxTranslate(horizontalSwipe, paperRef.current);\n    var translate = getTranslate(horizontalSwipe ? currentX : currentY, startLocation, openRef.current, maxTranslate);\n\n    if (swipeInstance.current.lastTranslate === null) {\n      swipeInstance.current.lastTranslate = translate;\n      swipeInstance.current.lastTime = performance.now() + 1;\n    }\n\n    var velocity = (translate - swipeInstance.current.lastTranslate) / (performance.now() - swipeInstance.current.lastTime) * 1e3; // Low Pass filter.\n\n    swipeInstance.current.velocity = swipeInstance.current.velocity * 0.4 + velocity * 0.6;\n    swipeInstance.current.lastTranslate = translate;\n    swipeInstance.current.lastTime = performance.now(); // We are swiping, let's prevent the scroll event on iOS.\n\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n\n    setPosition(translate);\n  }, [setPosition, handleBodyTouchEnd, anchor, disableDiscovery, swipeAreaWidth, theme]);\n  var handleBodyTouchStart = React.useCallback(function (event) {\n    // We are not supposed to handle this touch move.\n    if (nodeThatClaimedTheSwipe !== null && nodeThatClaimedTheSwipe !== swipeInstance.current) {\n      return;\n    }\n\n    var anchorRtl = getAnchor(theme, anchor);\n    var horizontalSwipe = isHorizontal(anchor);\n    var currentX = calculateCurrentX(anchorRtl, event.touches);\n    var currentY = calculateCurrentY(anchorRtl, event.touches);\n\n    if (!openRef.current) {\n      if (disableSwipeToOpen || event.target !== swipeAreaRef.current) {\n        return;\n      }\n\n      if (horizontalSwipe) {\n        if (currentX > swipeAreaWidth) {\n          return;\n        }\n      } else if (currentY > swipeAreaWidth) {\n        return;\n      }\n    }\n\n    nodeThatClaimedTheSwipe = swipeInstance.current;\n    swipeInstance.current.startX = currentX;\n    swipeInstance.current.startY = currentY;\n    setMaybeSwiping(true);\n\n    if (!openRef.current && paperRef.current) {\n      // The ref may be null when a parent component updates while swiping.\n      setPosition(getMaxTranslate(horizontalSwipe, paperRef.current) + (disableDiscovery ? 20 : -swipeAreaWidth), {\n        changeTransition: false\n      });\n    }\n\n    swipeInstance.current.velocity = 0;\n    swipeInstance.current.lastTime = null;\n    swipeInstance.current.lastTranslate = null;\n    touchDetected.current = true;\n  }, [setPosition, anchor, disableDiscovery, disableSwipeToOpen, swipeAreaWidth, theme]);\n  React.useEffect(function () {\n    if (variant === 'temporary') {\n      document.body.addEventListener('touchstart', handleBodyTouchStart);\n      document.body.addEventListener('touchmove', handleBodyTouchMove, {\n        passive: false\n      });\n      document.body.addEventListener('touchend', handleBodyTouchEnd);\n      return function () {\n        document.body.removeEventListener('touchstart', handleBodyTouchStart);\n        document.body.removeEventListener('touchmove', handleBodyTouchMove, {\n          passive: false\n        });\n        document.body.removeEventListener('touchend', handleBodyTouchEnd);\n      };\n    }\n\n    return undefined;\n  }, [variant, handleBodyTouchStart, handleBodyTouchMove, handleBodyTouchEnd]);\n  React.useEffect(function () {\n    return function () {\n      // We need to release the lock.\n      if (nodeThatClaimedTheSwipe === swipeInstance.current) {\n        nodeThatClaimedTheSwipe = null;\n      }\n    };\n  }, []);\n  React.useEffect(function () {\n    if (!open) {\n      setMaybeSwiping(false);\n    }\n  }, [open]);\n  var handleBackdropRef = React.useCallback(function (instance) {\n    // #StrictMode ready\n    backdropRef.current = ReactDOM.findDOMNode(instance);\n  }, []);\n  var handlePaperRef = React.useCallback(function (instance) {\n    // #StrictMode ready\n    paperRef.current = ReactDOM.findDOMNode(instance);\n  }, []);\n  return React.createElement(React.Fragment, null, React.createElement(Drawer, _extends({\n    open: variant === 'temporary' && maybeSwiping ? true : open,\n    variant: variant,\n    ModalProps: _extends({\n      BackdropProps: _extends({}, BackdropProps, {\n        ref: handleBackdropRef\n      })\n    }, ModalPropsProp),\n    PaperProps: _extends({}, PaperProps, {\n      style: _extends({\n        pointerEvents: variant === 'temporary' && !open ? 'none' : ''\n      }, PaperProps.style),\n      ref: handlePaperRef\n    }),\n    anchor: anchor,\n    transitionDuration: transitionDuration,\n    onClose: onClose,\n    ref: ref\n  }, other)), !disableSwipeToOpen && variant === 'temporary' && React.createElement(NoSsr, null, React.createElement(SwipeArea, _extends({\n    anchor: anchor,\n    ref: swipeAreaRef,\n    width: swipeAreaWidth\n  }, SwipeAreaProps))));\n});\nprocess.env.NODE_ENV !== \"production\" ? SwipeableDrawer.propTypes = {\n  /**\n   * @ignore\n   */\n  anchor: PropTypes.oneOf(['left', 'top', 'right', 'bottom']),\n\n  /**\n   * Disable the backdrop transition.\n   * This can improve the FPS on low-end devices.\n   */\n  disableBackdropTransition: PropTypes.bool,\n\n  /**\n   * If `true`, touching the screen near the edge of the drawer will not slide in the drawer a bit\n   * to promote accidental discovery of the swipe gesture.\n   */\n  disableDiscovery: PropTypes.bool,\n\n  /**\n   * If `true`, swipe to open is disabled. This is useful in browsers where swiping triggers\n   * navigation actions. Swipe to open is disabled on iOS browsers by default.\n   */\n  disableSwipeToOpen: PropTypes.bool,\n\n  /**\n   * @ignore\n   */\n  hideBackdrop: PropTypes.bool,\n\n  /**\n   * Affects how far the drawer must be opened/closed to change his state.\n   * Specified as percent (0-1) of the width of the drawer\n   */\n  hysteresis: PropTypes.number,\n\n  /**\n   * Defines, from which (average) velocity on, the swipe is\n   * defined as complete although hysteresis isn't reached.\n   * Good threshold is between 250 - 1000 px/s\n   */\n  minFlingVelocity: PropTypes.number,\n\n  /**\n   * @ignore\n   */\n  ModalProps: PropTypes.shape({\n    BackdropProps: PropTypes.shape({\n      component: elementTypeAcceptingRef\n    })\n  }),\n\n  /**\n   * Callback fired when the component requests to be closed.\n   *\n   * @param {object} event The event source of the callback\n   */\n  onClose: PropTypes.func.isRequired,\n\n  /**\n   * Callback fired when the component requests to be opened.\n   *\n   * @param {object} event The event source of the callback\n   */\n  onOpen: PropTypes.func.isRequired,\n\n  /**\n   * If `true`, the drawer is open.\n   */\n  open: PropTypes.bool.isRequired,\n\n  /**\n   * @ignore\n   */\n  PaperProps: PropTypes.shape({\n    component: elementTypeAcceptingRef\n  }),\n\n  /**\n   * Properties applied to the swipe area element.\n   */\n  SwipeAreaProps: PropTypes.object,\n\n  /**\n   * The width of the left most (or right most) area in pixels where the\n   * drawer can be swiped open from.\n   */\n  swipeAreaWidth: PropTypes.number,\n\n  /**\n   * @ignore\n   */\n  theme: PropTypes.object.isRequired,\n\n  /**\n   * The duration for the transition, in milliseconds.\n   * You may specify a single timeout for all transitions, or individually with an object.\n   */\n  transitionDuration: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({\n    enter: PropTypes.number,\n    exit: PropTypes.number\n  })]),\n\n  /**\n   * @ignore\n   */\n  variant: PropTypes.oneOf(['permanent', 'persistent', 'temporary'])\n} : void 0;\nSwipeableDrawer.defaultProps = {\n  anchor: 'left',\n  disableBackdropTransition: false,\n  disableDiscovery: false,\n  disableSwipeToOpen: typeof navigator !== 'undefined' && /iPad|iPhone|iPod/.test(navigator.userAgent),\n  hysteresis: 0.55,\n  minFlingVelocity: 400,\n  swipeAreaWidth: 20,\n  transitionDuration: {\n    enter: duration.enteringScreen,\n    exit: duration.leavingScreen\n  },\n  variant: 'temporary' // Mobile first.\n\n};\nexport default withTheme(SwipeableDrawer);"]},"metadata":{},"sourceType":"module"}