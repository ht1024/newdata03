{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport ReactDOM from 'react-dom';\nimport { elementTypeAcceptingRef } from '@material-ui/utils';\nimport Drawer, { getAnchor, isHorizontal } from '../Drawer/Drawer';\nimport { duration } from '../styles/transitions';\nimport withTheme from '../styles/withTheme';\nimport { getTransitionProps } from '../transitions/utils';\nimport NoSsr from '../NoSsr';\nimport SwipeArea from './SwipeArea'; // This value is closed to what browsers are using internally to\n// trigger a native scroll.\n\nvar UNCERTAINTY_THRESHOLD = 3; // px\n// We can only have one node at the time claiming ownership for handling the swipe.\n// Otherwise, the UX would be confusing.\n// That's why we use a singleton here.\n\nvar nodeThatClaimedTheSwipe = null; // Exported for test purposes.\n\nexport function reset() {\n  nodeThatClaimedTheSwipe = null;\n}\nfunction calculateCurrentX(anchor, touches) {\n  return anchor === 'right' ? document.body.offsetWidth - touches[0].pageX : touches[0].pageX;\n}\nfunction calculateCurrentY(anchor, touches) {\n  return anchor === 'bottom' ? window.innerHeight - touches[0].clientY : touches[0].clientY;\n}\nfunction getMaxTranslate(horizontalSwipe, paperInstance) {\n  return horizontalSwipe ? paperInstance.clientWidth : paperInstance.clientHeight;\n}\nfunction getTranslate(currentTranslate, startLocation, open, maxTranslate) {\n  return Math.min(Math.max(open ? startLocation - currentTranslate : maxTranslate + startLocation - currentTranslate, 0), maxTranslate);\n}\nvar useEnhancedEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;\nvar SwipeableDrawer = React.forwardRef(function SwipeableDrawer(props, ref) {\n  var anchor = props.anchor,\n    disableBackdropTransition = props.disableBackdropTransition,\n    disableDiscovery = props.disableDiscovery,\n    disableSwipeToOpen = props.disableSwipeToOpen,\n    hideBackdrop = props.hideBackdrop,\n    hysteresis = props.hysteresis,\n    minFlingVelocity = props.minFlingVelocity,\n    _props$ModalProps = props.ModalProps;\n  _props$ModalProps = _props$ModalProps === void 0 ? {} : _props$ModalProps;\n  var BackdropProps = _props$ModalProps.BackdropProps,\n    ModalPropsProp = _objectWithoutProperties(_props$ModalProps, [\"BackdropProps\"]),\n    onClose = props.onClose,\n    onOpen = props.onOpen,\n    open = props.open,\n    _props$PaperProps = props.PaperProps,\n    PaperProps = _props$PaperProps === void 0 ? {} : _props$PaperProps,\n    SwipeAreaProps = props.SwipeAreaProps,\n    swipeAreaWidth = props.swipeAreaWidth,\n    theme = props.theme,\n    transitionDuration = props.transitionDuration,\n    variant = props.variant,\n    other = _objectWithoutProperties(props, [\"anchor\", \"disableBackdropTransition\", \"disableDiscovery\", \"disableSwipeToOpen\", \"hideBackdrop\", \"hysteresis\", \"minFlingVelocity\", \"ModalProps\", \"onClose\", \"onOpen\", \"open\", \"PaperProps\", \"SwipeAreaProps\", \"swipeAreaWidth\", \"theme\", \"transitionDuration\", \"variant\"]);\n  var _React$useState = React.useState(false),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    maybeSwiping = _React$useState2[0],\n    setMaybeSwiping = _React$useState2[1];\n  var swipeInstance = React.useRef({\n    isSwiping: null\n  });\n  var swipeAreaRef = React.useRef();\n  var backdropRef = React.useRef();\n  var paperRef = React.useRef();\n  var touchDetected = React.useRef(false);\n  var openRef = React.useRef(open); // Use a ref so the open value used is always up to date inside useCallback.\n\n  useEnhancedEffect(function () {\n    openRef.current = open;\n  }, [open]);\n  var setPosition = React.useCallback(function (translate) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$mode = options.mode,\n      mode = _options$mode === void 0 ? null : _options$mode,\n      _options$changeTransi = options.changeTransition,\n      changeTransition = _options$changeTransi === void 0 ? true : _options$changeTransi;\n    var anchorRtl = getAnchor(theme, anchor);\n    var rtlTranslateMultiplier = ['right', 'bottom'].indexOf(anchorRtl) !== -1 ? 1 : -1;\n    var horizontalSwipe = isHorizontal(anchor);\n    var transform = horizontalSwipe ? \"translate(\".concat(rtlTranslateMultiplier * translate, \"px, 0)\") : \"translate(0, \".concat(rtlTranslateMultiplier * translate, \"px)\");\n    var drawerStyle = paperRef.current.style;\n    drawerStyle.webkitTransform = transform;\n    drawerStyle.transform = transform;\n    var transition = '';\n    if (mode) {\n      transition = theme.transitions.create('all', getTransitionProps({\n        timeout: transitionDuration\n      }, {\n        mode: mode\n      }));\n    }\n    if (changeTransition) {\n      drawerStyle.webkitTransition = transition;\n      drawerStyle.transition = transition;\n    }\n    if (!disableBackdropTransition && !hideBackdrop) {\n      var backdropStyle = backdropRef.current.style;\n      backdropStyle.opacity = 1 - translate / getMaxTranslate(horizontalSwipe, paperRef.current);\n      if (changeTransition) {\n        backdropStyle.webkitTransition = transition;\n        backdropStyle.transition = transition;\n      }\n    }\n  }, [anchor, disableBackdropTransition, hideBackdrop, theme, transitionDuration]);\n  var handleBodyTouchEnd = React.useCallback(function (event) {\n    if (!touchDetected.current) {\n      return;\n    }\n    nodeThatClaimedTheSwipe = null;\n    touchDetected.current = false;\n    setMaybeSwiping(false); // The swipe wasn't started.\n\n    if (!swipeInstance.current.isSwiping) {\n      swipeInstance.current.isSwiping = null;\n      return;\n    }\n    swipeInstance.current.isSwiping = null;\n    var anchorRtl = getAnchor(theme, anchor);\n    var horizontal = isHorizontal(anchor);\n    var current;\n    if (horizontal) {\n      current = calculateCurrentX(anchorRtl, event.changedTouches);\n    } else {\n      current = calculateCurrentY(anchorRtl, event.changedTouches);\n    }\n    var startLocation = horizontal ? swipeInstance.current.startX : swipeInstance.current.startY;\n    var maxTranslate = getMaxTranslate(horizontal, paperRef.current);\n    var currentTranslate = getTranslate(current, startLocation, openRef.current, maxTranslate);\n    var translateRatio = currentTranslate / maxTranslate;\n    if (openRef.current) {\n      if (swipeInstance.current.velocity > minFlingVelocity || translateRatio > hysteresis) {\n        onClose();\n      } else {\n        // Reset the position, the swipe was aborted.\n        setPosition(0, {\n          mode: 'exit'\n        });\n      }\n      return;\n    }\n    if (swipeInstance.current.velocity < -minFlingVelocity || 1 - translateRatio > hysteresis) {\n      onOpen();\n    } else {\n      // Reset the position, the swipe was aborted.\n      setPosition(getMaxTranslate(horizontal, paperRef.current), {\n        mode: 'enter'\n      });\n    }\n  }, [anchor, hysteresis, minFlingVelocity, onClose, onOpen, setPosition, theme]);\n  var handleBodyTouchMove = React.useCallback(function (event) {\n    // the ref may be null when a parent component updates while swiping\n    if (!paperRef.current || !touchDetected.current) {\n      return;\n    }\n    var anchorRtl = getAnchor(theme, anchor);\n    var horizontalSwipe = isHorizontal(anchor);\n    var currentX = calculateCurrentX(anchorRtl, event.touches);\n    var currentY = calculateCurrentY(anchorRtl, event.touches); // We don't know yet.\n\n    if (swipeInstance.current.isSwiping == null) {\n      var dx = Math.abs(currentX - swipeInstance.current.startX);\n      var dy = Math.abs(currentY - swipeInstance.current.startY); // We are likely to be swiping, let's prevent the scroll event on iOS.\n\n      if (dx > dy) {\n        if (event.cancelable) {\n          event.preventDefault();\n        }\n      }\n      var definitelySwiping = horizontalSwipe ? dx > dy && dx > UNCERTAINTY_THRESHOLD : dy > dx && dy > UNCERTAINTY_THRESHOLD;\n      if (definitelySwiping === true || (horizontalSwipe ? dy > UNCERTAINTY_THRESHOLD : dx > UNCERTAINTY_THRESHOLD)) {\n        swipeInstance.current.isSwiping = definitelySwiping;\n        if (!definitelySwiping) {\n          handleBodyTouchEnd(event);\n          return;\n        } // Shift the starting point.\n\n        swipeInstance.current.startX = currentX;\n        swipeInstance.current.startY = currentY; // Compensate for the part of the drawer displayed on touch start.\n\n        if (!disableDiscovery && !openRef.current) {\n          if (horizontalSwipe) {\n            swipeInstance.current.startX -= swipeAreaWidth;\n          } else {\n            swipeInstance.current.startY -= swipeAreaWidth;\n          }\n        }\n      }\n    }\n    if (!swipeInstance.current.isSwiping) {\n      return;\n    }\n    var startLocation = horizontalSwipe ? swipeInstance.current.startX : swipeInstance.current.startY;\n    var maxTranslate = getMaxTranslate(horizontalSwipe, paperRef.current);\n    var translate = getTranslate(horizontalSwipe ? currentX : currentY, startLocation, openRef.current, maxTranslate);\n    if (swipeInstance.current.lastTranslate === null) {\n      swipeInstance.current.lastTranslate = translate;\n      swipeInstance.current.lastTime = performance.now() + 1;\n    }\n    var velocity = (translate - swipeInstance.current.lastTranslate) / (performance.now() - swipeInstance.current.lastTime) * 1e3; // Low Pass filter.\n\n    swipeInstance.current.velocity = swipeInstance.current.velocity * 0.4 + velocity * 0.6;\n    swipeInstance.current.lastTranslate = translate;\n    swipeInstance.current.lastTime = performance.now(); // We are swiping, let's prevent the scroll event on iOS.\n\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n    setPosition(translate);\n  }, [setPosition, handleBodyTouchEnd, anchor, disableDiscovery, swipeAreaWidth, theme]);\n  var handleBodyTouchStart = React.useCallback(function (event) {\n    // We are not supposed to handle this touch move.\n    if (nodeThatClaimedTheSwipe !== null && nodeThatClaimedTheSwipe !== swipeInstance.current) {\n      return;\n    }\n    var anchorRtl = getAnchor(theme, anchor);\n    var horizontalSwipe = isHorizontal(anchor);\n    var currentX = calculateCurrentX(anchorRtl, event.touches);\n    var currentY = calculateCurrentY(anchorRtl, event.touches);\n    if (!openRef.current) {\n      if (disableSwipeToOpen || event.target !== swipeAreaRef.current) {\n        return;\n      }\n      if (horizontalSwipe) {\n        if (currentX > swipeAreaWidth) {\n          return;\n        }\n      } else if (currentY > swipeAreaWidth) {\n        return;\n      }\n    }\n    nodeThatClaimedTheSwipe = swipeInstance.current;\n    swipeInstance.current.startX = currentX;\n    swipeInstance.current.startY = currentY;\n    setMaybeSwiping(true);\n    if (!openRef.current && paperRef.current) {\n      // The ref may be null when a parent component updates while swiping.\n      setPosition(getMaxTranslate(horizontalSwipe, paperRef.current) + (disableDiscovery ? 20 : -swipeAreaWidth), {\n        changeTransition: false\n      });\n    }\n    swipeInstance.current.velocity = 0;\n    swipeInstance.current.lastTime = null;\n    swipeInstance.current.lastTranslate = null;\n    touchDetected.current = true;\n  }, [setPosition, anchor, disableDiscovery, disableSwipeToOpen, swipeAreaWidth, theme]);\n  React.useEffect(function () {\n    if (variant === 'temporary') {\n      document.body.addEventListener('touchstart', handleBodyTouchStart);\n      document.body.addEventListener('touchmove', handleBodyTouchMove, {\n        passive: false\n      });\n      document.body.addEventListener('touchend', handleBodyTouchEnd);\n      return function () {\n        document.body.removeEventListener('touchstart', handleBodyTouchStart);\n        document.body.removeEventListener('touchmove', handleBodyTouchMove, {\n          passive: false\n        });\n        document.body.removeEventListener('touchend', handleBodyTouchEnd);\n      };\n    }\n    return undefined;\n  }, [variant, handleBodyTouchStart, handleBodyTouchMove, handleBodyTouchEnd]);\n  React.useEffect(function () {\n    return function () {\n      // We need to release the lock.\n      if (nodeThatClaimedTheSwipe === swipeInstance.current) {\n        nodeThatClaimedTheSwipe = null;\n      }\n    };\n  }, []);\n  React.useEffect(function () {\n    if (!open) {\n      setMaybeSwiping(false);\n    }\n  }, [open]);\n  var handleBackdropRef = React.useCallback(function (instance) {\n    // #StrictMode ready\n    backdropRef.current = ReactDOM.findDOMNode(instance);\n  }, []);\n  var handlePaperRef = React.useCallback(function (instance) {\n    // #StrictMode ready\n    paperRef.current = ReactDOM.findDOMNode(instance);\n  }, []);\n  return React.createElement(React.Fragment, null, React.createElement(Drawer, _extends({\n    open: variant === 'temporary' && maybeSwiping ? true : open,\n    variant: variant,\n    ModalProps: _extends({\n      BackdropProps: _extends({}, BackdropProps, {\n        ref: handleBackdropRef\n      })\n    }, ModalPropsProp),\n    PaperProps: _extends({}, PaperProps, {\n      style: _extends({\n        pointerEvents: variant === 'temporary' && !open ? 'none' : ''\n      }, PaperProps.style),\n      ref: handlePaperRef\n    }),\n    anchor: anchor,\n    transitionDuration: transitionDuration,\n    onClose: onClose,\n    ref: ref\n  }, other)), !disableSwipeToOpen && variant === 'temporary' && React.createElement(NoSsr, null, React.createElement(SwipeArea, _extends({\n    anchor: anchor,\n    ref: swipeAreaRef,\n    width: swipeAreaWidth\n  }, SwipeAreaProps))));\n});\nprocess.env.NODE_ENV !== \"production\" ? SwipeableDrawer.propTypes = {\n  /**\n   * @ignore\n   */\n  anchor: PropTypes.oneOf(['left', 'top', 'right', 'bottom']),\n  /**\n   * Disable the backdrop transition.\n   * This can improve the FPS on low-end devices.\n   */\n  disableBackdropTransition: PropTypes.bool,\n  /**\n   * If `true`, touching the screen near the edge of the drawer will not slide in the drawer a bit\n   * to promote accidental discovery of the swipe gesture.\n   */\n  disableDiscovery: PropTypes.bool,\n  /**\n   * If `true`, swipe to open is disabled. This is useful in browsers where swiping triggers\n   * navigation actions. Swipe to open is disabled on iOS browsers by default.\n   */\n  disableSwipeToOpen: PropTypes.bool,\n  /**\n   * @ignore\n   */\n  hideBackdrop: PropTypes.bool,\n  /**\n   * Affects how far the drawer must be opened/closed to change his state.\n   * Specified as percent (0-1) of the width of the drawer\n   */\n  hysteresis: PropTypes.number,\n  /**\n   * Defines, from which (average) velocity on, the swipe is\n   * defined as complete although hysteresis isn't reached.\n   * Good threshold is between 250 - 1000 px/s\n   */\n  minFlingVelocity: PropTypes.number,\n  /**\n   * @ignore\n   */\n  ModalProps: PropTypes.shape({\n    BackdropProps: PropTypes.shape({\n      component: elementTypeAcceptingRef\n    })\n  }),\n  /**\n   * Callback fired when the component requests to be closed.\n   *\n   * @param {object} event The event source of the callback\n   */\n  onClose: PropTypes.func.isRequired,\n  /**\n   * Callback fired when the component requests to be opened.\n   *\n   * @param {object} event The event source of the callback\n   */\n  onOpen: PropTypes.func.isRequired,\n  /**\n   * If `true`, the drawer is open.\n   */\n  open: PropTypes.bool.isRequired,\n  /**\n   * @ignore\n   */\n  PaperProps: PropTypes.shape({\n    component: elementTypeAcceptingRef\n  }),\n  /**\n   * Properties applied to the swipe area element.\n   */\n  SwipeAreaProps: PropTypes.object,\n  /**\n   * The width of the left most (or right most) area in pixels where the\n   * drawer can be swiped open from.\n   */\n  swipeAreaWidth: PropTypes.number,\n  /**\n   * @ignore\n   */\n  theme: PropTypes.object.isRequired,\n  /**\n   * The duration for the transition, in milliseconds.\n   * You may specify a single timeout for all transitions, or individually with an object.\n   */\n  transitionDuration: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({\n    enter: PropTypes.number,\n    exit: PropTypes.number\n  })]),\n  /**\n   * @ignore\n   */\n  variant: PropTypes.oneOf(['permanent', 'persistent', 'temporary'])\n} : void 0;\nSwipeableDrawer.defaultProps = {\n  anchor: 'left',\n  disableBackdropTransition: false,\n  disableDiscovery: false,\n  disableSwipeToOpen: typeof navigator !== 'undefined' && /iPad|iPhone|iPod/.test(navigator.userAgent),\n  hysteresis: 0.55,\n  minFlingVelocity: 400,\n  swipeAreaWidth: 20,\n  transitionDuration: {\n    enter: duration.enteringScreen,\n    exit: duration.leavingScreen\n  },\n  variant: 'temporary' // Mobile first.\n};\n\nexport default withTheme(SwipeableDrawer);","map":{"version":3,"names":["_extends","_slicedToArray","_objectWithoutProperties","React","PropTypes","ReactDOM","elementTypeAcceptingRef","Drawer","getAnchor","isHorizontal","duration","withTheme","getTransitionProps","NoSsr","SwipeArea","UNCERTAINTY_THRESHOLD","nodeThatClaimedTheSwipe","reset","calculateCurrentX","anchor","touches","document","body","offsetWidth","pageX","calculateCurrentY","window","innerHeight","clientY","getMaxTranslate","horizontalSwipe","paperInstance","clientWidth","clientHeight","getTranslate","currentTranslate","startLocation","open","maxTranslate","Math","min","max","useEnhancedEffect","useLayoutEffect","useEffect","SwipeableDrawer","forwardRef","props","ref","disableBackdropTransition","disableDiscovery","disableSwipeToOpen","hideBackdrop","hysteresis","minFlingVelocity","_props$ModalProps","ModalProps","BackdropProps","ModalPropsProp","onClose","onOpen","_props$PaperProps","PaperProps","SwipeAreaProps","swipeAreaWidth","theme","transitionDuration","variant","other","_React$useState","useState","_React$useState2","maybeSwiping","setMaybeSwiping","swipeInstance","useRef","isSwiping","swipeAreaRef","backdropRef","paperRef","touchDetected","openRef","current","setPosition","useCallback","translate","options","arguments","length","undefined","_options$mode","mode","_options$changeTransi","changeTransition","anchorRtl","rtlTranslateMultiplier","indexOf","transform","concat","drawerStyle","style","webkitTransform","transition","transitions","create","timeout","webkitTransition","backdropStyle","opacity","handleBodyTouchEnd","event","horizontal","changedTouches","startX","startY","translateRatio","velocity","handleBodyTouchMove","currentX","currentY","dx","abs","dy","cancelable","preventDefault","definitelySwiping","lastTranslate","lastTime","performance","now","handleBodyTouchStart","target","addEventListener","passive","removeEventListener","handleBackdropRef","instance","findDOMNode","handlePaperRef","createElement","Fragment","pointerEvents","width","process","env","NODE_ENV","propTypes","oneOf","bool","number","shape","component","func","isRequired","object","oneOfType","enter","exit","defaultProps","navigator","test","userAgent","enteringScreen","leavingScreen"],"sources":["/Users/tristan15/Documents/GitHub/newdata03/node_modules/@material-ui/core/esm/SwipeableDrawer/SwipeableDrawer.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/extends\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport ReactDOM from 'react-dom';\nimport { elementTypeAcceptingRef } from '@material-ui/utils';\nimport Drawer, { getAnchor, isHorizontal } from '../Drawer/Drawer';\nimport { duration } from '../styles/transitions';\nimport withTheme from '../styles/withTheme';\nimport { getTransitionProps } from '../transitions/utils';\nimport NoSsr from '../NoSsr';\nimport SwipeArea from './SwipeArea'; // This value is closed to what browsers are using internally to\n// trigger a native scroll.\n\nvar UNCERTAINTY_THRESHOLD = 3; // px\n// We can only have one node at the time claiming ownership for handling the swipe.\n// Otherwise, the UX would be confusing.\n// That's why we use a singleton here.\n\nvar nodeThatClaimedTheSwipe = null; // Exported for test purposes.\n\nexport function reset() {\n  nodeThatClaimedTheSwipe = null;\n}\n\nfunction calculateCurrentX(anchor, touches) {\n  return anchor === 'right' ? document.body.offsetWidth - touches[0].pageX : touches[0].pageX;\n}\n\nfunction calculateCurrentY(anchor, touches) {\n  return anchor === 'bottom' ? window.innerHeight - touches[0].clientY : touches[0].clientY;\n}\n\nfunction getMaxTranslate(horizontalSwipe, paperInstance) {\n  return horizontalSwipe ? paperInstance.clientWidth : paperInstance.clientHeight;\n}\n\nfunction getTranslate(currentTranslate, startLocation, open, maxTranslate) {\n  return Math.min(Math.max(open ? startLocation - currentTranslate : maxTranslate + startLocation - currentTranslate, 0), maxTranslate);\n}\n\nvar useEnhancedEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;\nvar SwipeableDrawer = React.forwardRef(function SwipeableDrawer(props, ref) {\n  var anchor = props.anchor,\n      disableBackdropTransition = props.disableBackdropTransition,\n      disableDiscovery = props.disableDiscovery,\n      disableSwipeToOpen = props.disableSwipeToOpen,\n      hideBackdrop = props.hideBackdrop,\n      hysteresis = props.hysteresis,\n      minFlingVelocity = props.minFlingVelocity,\n      _props$ModalProps = props.ModalProps;\n  _props$ModalProps = _props$ModalProps === void 0 ? {} : _props$ModalProps;\n\n  var BackdropProps = _props$ModalProps.BackdropProps,\n      ModalPropsProp = _objectWithoutProperties(_props$ModalProps, [\"BackdropProps\"]),\n      onClose = props.onClose,\n      onOpen = props.onOpen,\n      open = props.open,\n      _props$PaperProps = props.PaperProps,\n      PaperProps = _props$PaperProps === void 0 ? {} : _props$PaperProps,\n      SwipeAreaProps = props.SwipeAreaProps,\n      swipeAreaWidth = props.swipeAreaWidth,\n      theme = props.theme,\n      transitionDuration = props.transitionDuration,\n      variant = props.variant,\n      other = _objectWithoutProperties(props, [\"anchor\", \"disableBackdropTransition\", \"disableDiscovery\", \"disableSwipeToOpen\", \"hideBackdrop\", \"hysteresis\", \"minFlingVelocity\", \"ModalProps\", \"onClose\", \"onOpen\", \"open\", \"PaperProps\", \"SwipeAreaProps\", \"swipeAreaWidth\", \"theme\", \"transitionDuration\", \"variant\"]);\n\n  var _React$useState = React.useState(false),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      maybeSwiping = _React$useState2[0],\n      setMaybeSwiping = _React$useState2[1];\n\n  var swipeInstance = React.useRef({\n    isSwiping: null\n  });\n  var swipeAreaRef = React.useRef();\n  var backdropRef = React.useRef();\n  var paperRef = React.useRef();\n  var touchDetected = React.useRef(false);\n  var openRef = React.useRef(open); // Use a ref so the open value used is always up to date inside useCallback.\n\n  useEnhancedEffect(function () {\n    openRef.current = open;\n  }, [open]);\n  var setPosition = React.useCallback(function (translate) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$mode = options.mode,\n        mode = _options$mode === void 0 ? null : _options$mode,\n        _options$changeTransi = options.changeTransition,\n        changeTransition = _options$changeTransi === void 0 ? true : _options$changeTransi;\n    var anchorRtl = getAnchor(theme, anchor);\n    var rtlTranslateMultiplier = ['right', 'bottom'].indexOf(anchorRtl) !== -1 ? 1 : -1;\n    var horizontalSwipe = isHorizontal(anchor);\n    var transform = horizontalSwipe ? \"translate(\".concat(rtlTranslateMultiplier * translate, \"px, 0)\") : \"translate(0, \".concat(rtlTranslateMultiplier * translate, \"px)\");\n    var drawerStyle = paperRef.current.style;\n    drawerStyle.webkitTransform = transform;\n    drawerStyle.transform = transform;\n    var transition = '';\n\n    if (mode) {\n      transition = theme.transitions.create('all', getTransitionProps({\n        timeout: transitionDuration\n      }, {\n        mode: mode\n      }));\n    }\n\n    if (changeTransition) {\n      drawerStyle.webkitTransition = transition;\n      drawerStyle.transition = transition;\n    }\n\n    if (!disableBackdropTransition && !hideBackdrop) {\n      var backdropStyle = backdropRef.current.style;\n      backdropStyle.opacity = 1 - translate / getMaxTranslate(horizontalSwipe, paperRef.current);\n\n      if (changeTransition) {\n        backdropStyle.webkitTransition = transition;\n        backdropStyle.transition = transition;\n      }\n    }\n  }, [anchor, disableBackdropTransition, hideBackdrop, theme, transitionDuration]);\n  var handleBodyTouchEnd = React.useCallback(function (event) {\n    if (!touchDetected.current) {\n      return;\n    }\n\n    nodeThatClaimedTheSwipe = null;\n    touchDetected.current = false;\n    setMaybeSwiping(false); // The swipe wasn't started.\n\n    if (!swipeInstance.current.isSwiping) {\n      swipeInstance.current.isSwiping = null;\n      return;\n    }\n\n    swipeInstance.current.isSwiping = null;\n    var anchorRtl = getAnchor(theme, anchor);\n    var horizontal = isHorizontal(anchor);\n    var current;\n\n    if (horizontal) {\n      current = calculateCurrentX(anchorRtl, event.changedTouches);\n    } else {\n      current = calculateCurrentY(anchorRtl, event.changedTouches);\n    }\n\n    var startLocation = horizontal ? swipeInstance.current.startX : swipeInstance.current.startY;\n    var maxTranslate = getMaxTranslate(horizontal, paperRef.current);\n    var currentTranslate = getTranslate(current, startLocation, openRef.current, maxTranslate);\n    var translateRatio = currentTranslate / maxTranslate;\n\n    if (openRef.current) {\n      if (swipeInstance.current.velocity > minFlingVelocity || translateRatio > hysteresis) {\n        onClose();\n      } else {\n        // Reset the position, the swipe was aborted.\n        setPosition(0, {\n          mode: 'exit'\n        });\n      }\n\n      return;\n    }\n\n    if (swipeInstance.current.velocity < -minFlingVelocity || 1 - translateRatio > hysteresis) {\n      onOpen();\n    } else {\n      // Reset the position, the swipe was aborted.\n      setPosition(getMaxTranslate(horizontal, paperRef.current), {\n        mode: 'enter'\n      });\n    }\n  }, [anchor, hysteresis, minFlingVelocity, onClose, onOpen, setPosition, theme]);\n  var handleBodyTouchMove = React.useCallback(function (event) {\n    // the ref may be null when a parent component updates while swiping\n    if (!paperRef.current || !touchDetected.current) {\n      return;\n    }\n\n    var anchorRtl = getAnchor(theme, anchor);\n    var horizontalSwipe = isHorizontal(anchor);\n    var currentX = calculateCurrentX(anchorRtl, event.touches);\n    var currentY = calculateCurrentY(anchorRtl, event.touches); // We don't know yet.\n\n    if (swipeInstance.current.isSwiping == null) {\n      var dx = Math.abs(currentX - swipeInstance.current.startX);\n      var dy = Math.abs(currentY - swipeInstance.current.startY); // We are likely to be swiping, let's prevent the scroll event on iOS.\n\n      if (dx > dy) {\n        if (event.cancelable) {\n          event.preventDefault();\n        }\n      }\n\n      var definitelySwiping = horizontalSwipe ? dx > dy && dx > UNCERTAINTY_THRESHOLD : dy > dx && dy > UNCERTAINTY_THRESHOLD;\n\n      if (definitelySwiping === true || (horizontalSwipe ? dy > UNCERTAINTY_THRESHOLD : dx > UNCERTAINTY_THRESHOLD)) {\n        swipeInstance.current.isSwiping = definitelySwiping;\n\n        if (!definitelySwiping) {\n          handleBodyTouchEnd(event);\n          return;\n        } // Shift the starting point.\n\n\n        swipeInstance.current.startX = currentX;\n        swipeInstance.current.startY = currentY; // Compensate for the part of the drawer displayed on touch start.\n\n        if (!disableDiscovery && !openRef.current) {\n          if (horizontalSwipe) {\n            swipeInstance.current.startX -= swipeAreaWidth;\n          } else {\n            swipeInstance.current.startY -= swipeAreaWidth;\n          }\n        }\n      }\n    }\n\n    if (!swipeInstance.current.isSwiping) {\n      return;\n    }\n\n    var startLocation = horizontalSwipe ? swipeInstance.current.startX : swipeInstance.current.startY;\n    var maxTranslate = getMaxTranslate(horizontalSwipe, paperRef.current);\n    var translate = getTranslate(horizontalSwipe ? currentX : currentY, startLocation, openRef.current, maxTranslate);\n\n    if (swipeInstance.current.lastTranslate === null) {\n      swipeInstance.current.lastTranslate = translate;\n      swipeInstance.current.lastTime = performance.now() + 1;\n    }\n\n    var velocity = (translate - swipeInstance.current.lastTranslate) / (performance.now() - swipeInstance.current.lastTime) * 1e3; // Low Pass filter.\n\n    swipeInstance.current.velocity = swipeInstance.current.velocity * 0.4 + velocity * 0.6;\n    swipeInstance.current.lastTranslate = translate;\n    swipeInstance.current.lastTime = performance.now(); // We are swiping, let's prevent the scroll event on iOS.\n\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n\n    setPosition(translate);\n  }, [setPosition, handleBodyTouchEnd, anchor, disableDiscovery, swipeAreaWidth, theme]);\n  var handleBodyTouchStart = React.useCallback(function (event) {\n    // We are not supposed to handle this touch move.\n    if (nodeThatClaimedTheSwipe !== null && nodeThatClaimedTheSwipe !== swipeInstance.current) {\n      return;\n    }\n\n    var anchorRtl = getAnchor(theme, anchor);\n    var horizontalSwipe = isHorizontal(anchor);\n    var currentX = calculateCurrentX(anchorRtl, event.touches);\n    var currentY = calculateCurrentY(anchorRtl, event.touches);\n\n    if (!openRef.current) {\n      if (disableSwipeToOpen || event.target !== swipeAreaRef.current) {\n        return;\n      }\n\n      if (horizontalSwipe) {\n        if (currentX > swipeAreaWidth) {\n          return;\n        }\n      } else if (currentY > swipeAreaWidth) {\n        return;\n      }\n    }\n\n    nodeThatClaimedTheSwipe = swipeInstance.current;\n    swipeInstance.current.startX = currentX;\n    swipeInstance.current.startY = currentY;\n    setMaybeSwiping(true);\n\n    if (!openRef.current && paperRef.current) {\n      // The ref may be null when a parent component updates while swiping.\n      setPosition(getMaxTranslate(horizontalSwipe, paperRef.current) + (disableDiscovery ? 20 : -swipeAreaWidth), {\n        changeTransition: false\n      });\n    }\n\n    swipeInstance.current.velocity = 0;\n    swipeInstance.current.lastTime = null;\n    swipeInstance.current.lastTranslate = null;\n    touchDetected.current = true;\n  }, [setPosition, anchor, disableDiscovery, disableSwipeToOpen, swipeAreaWidth, theme]);\n  React.useEffect(function () {\n    if (variant === 'temporary') {\n      document.body.addEventListener('touchstart', handleBodyTouchStart);\n      document.body.addEventListener('touchmove', handleBodyTouchMove, {\n        passive: false\n      });\n      document.body.addEventListener('touchend', handleBodyTouchEnd);\n      return function () {\n        document.body.removeEventListener('touchstart', handleBodyTouchStart);\n        document.body.removeEventListener('touchmove', handleBodyTouchMove, {\n          passive: false\n        });\n        document.body.removeEventListener('touchend', handleBodyTouchEnd);\n      };\n    }\n\n    return undefined;\n  }, [variant, handleBodyTouchStart, handleBodyTouchMove, handleBodyTouchEnd]);\n  React.useEffect(function () {\n    return function () {\n      // We need to release the lock.\n      if (nodeThatClaimedTheSwipe === swipeInstance.current) {\n        nodeThatClaimedTheSwipe = null;\n      }\n    };\n  }, []);\n  React.useEffect(function () {\n    if (!open) {\n      setMaybeSwiping(false);\n    }\n  }, [open]);\n  var handleBackdropRef = React.useCallback(function (instance) {\n    // #StrictMode ready\n    backdropRef.current = ReactDOM.findDOMNode(instance);\n  }, []);\n  var handlePaperRef = React.useCallback(function (instance) {\n    // #StrictMode ready\n    paperRef.current = ReactDOM.findDOMNode(instance);\n  }, []);\n  return React.createElement(React.Fragment, null, React.createElement(Drawer, _extends({\n    open: variant === 'temporary' && maybeSwiping ? true : open,\n    variant: variant,\n    ModalProps: _extends({\n      BackdropProps: _extends({}, BackdropProps, {\n        ref: handleBackdropRef\n      })\n    }, ModalPropsProp),\n    PaperProps: _extends({}, PaperProps, {\n      style: _extends({\n        pointerEvents: variant === 'temporary' && !open ? 'none' : ''\n      }, PaperProps.style),\n      ref: handlePaperRef\n    }),\n    anchor: anchor,\n    transitionDuration: transitionDuration,\n    onClose: onClose,\n    ref: ref\n  }, other)), !disableSwipeToOpen && variant === 'temporary' && React.createElement(NoSsr, null, React.createElement(SwipeArea, _extends({\n    anchor: anchor,\n    ref: swipeAreaRef,\n    width: swipeAreaWidth\n  }, SwipeAreaProps))));\n});\nprocess.env.NODE_ENV !== \"production\" ? SwipeableDrawer.propTypes = {\n  /**\n   * @ignore\n   */\n  anchor: PropTypes.oneOf(['left', 'top', 'right', 'bottom']),\n\n  /**\n   * Disable the backdrop transition.\n   * This can improve the FPS on low-end devices.\n   */\n  disableBackdropTransition: PropTypes.bool,\n\n  /**\n   * If `true`, touching the screen near the edge of the drawer will not slide in the drawer a bit\n   * to promote accidental discovery of the swipe gesture.\n   */\n  disableDiscovery: PropTypes.bool,\n\n  /**\n   * If `true`, swipe to open is disabled. This is useful in browsers where swiping triggers\n   * navigation actions. Swipe to open is disabled on iOS browsers by default.\n   */\n  disableSwipeToOpen: PropTypes.bool,\n\n  /**\n   * @ignore\n   */\n  hideBackdrop: PropTypes.bool,\n\n  /**\n   * Affects how far the drawer must be opened/closed to change his state.\n   * Specified as percent (0-1) of the width of the drawer\n   */\n  hysteresis: PropTypes.number,\n\n  /**\n   * Defines, from which (average) velocity on, the swipe is\n   * defined as complete although hysteresis isn't reached.\n   * Good threshold is between 250 - 1000 px/s\n   */\n  minFlingVelocity: PropTypes.number,\n\n  /**\n   * @ignore\n   */\n  ModalProps: PropTypes.shape({\n    BackdropProps: PropTypes.shape({\n      component: elementTypeAcceptingRef\n    })\n  }),\n\n  /**\n   * Callback fired when the component requests to be closed.\n   *\n   * @param {object} event The event source of the callback\n   */\n  onClose: PropTypes.func.isRequired,\n\n  /**\n   * Callback fired when the component requests to be opened.\n   *\n   * @param {object} event The event source of the callback\n   */\n  onOpen: PropTypes.func.isRequired,\n\n  /**\n   * If `true`, the drawer is open.\n   */\n  open: PropTypes.bool.isRequired,\n\n  /**\n   * @ignore\n   */\n  PaperProps: PropTypes.shape({\n    component: elementTypeAcceptingRef\n  }),\n\n  /**\n   * Properties applied to the swipe area element.\n   */\n  SwipeAreaProps: PropTypes.object,\n\n  /**\n   * The width of the left most (or right most) area in pixels where the\n   * drawer can be swiped open from.\n   */\n  swipeAreaWidth: PropTypes.number,\n\n  /**\n   * @ignore\n   */\n  theme: PropTypes.object.isRequired,\n\n  /**\n   * The duration for the transition, in milliseconds.\n   * You may specify a single timeout for all transitions, or individually with an object.\n   */\n  transitionDuration: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({\n    enter: PropTypes.number,\n    exit: PropTypes.number\n  })]),\n\n  /**\n   * @ignore\n   */\n  variant: PropTypes.oneOf(['permanent', 'persistent', 'temporary'])\n} : void 0;\nSwipeableDrawer.defaultProps = {\n  anchor: 'left',\n  disableBackdropTransition: false,\n  disableDiscovery: false,\n  disableSwipeToOpen: typeof navigator !== 'undefined' && /iPad|iPhone|iPod/.test(navigator.userAgent),\n  hysteresis: 0.55,\n  minFlingVelocity: 400,\n  swipeAreaWidth: 20,\n  transitionDuration: {\n    enter: duration.enteringScreen,\n    exit: duration.leavingScreen\n  },\n  variant: 'temporary' // Mobile first.\n\n};\nexport default withTheme(SwipeableDrawer);"],"mappings":"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"},"metadata":{},"sourceType":"module"}